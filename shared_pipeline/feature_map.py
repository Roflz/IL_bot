"""
Feature Mapping Module for OSRS Bot Imitation Learning

This module handles loading and validation of feature mappings from feature_mappings.json.
It dynamically handles the feature structure generated by the feature extraction workflow.
"""

import json
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any


def load_feature_mappings(mappings_file: str = "data/features/feature_mappings.json") -> List[Dict]:
    """
    Load feature mappings from JSON file.
    
    Args:
        mappings_file: Path to feature_mappings.json
        
    Returns:
        List of feature mapping dictionaries with keys:
        - feature_index: int (0 to n-1)
        - feature_name: str
        - data_type: str
        - feature_group: str
        
    Raises:
        FileNotFoundError: If mappings file doesn't exist
        ValueError: If mappings structure is invalid
    """
    mappings_path = Path(mappings_file)
    if not mappings_path.exists():
        raise FileNotFoundError(f"Feature mappings file not found: {mappings_path}")
    
    with open(mappings_path, 'r') as f:
        mappings = json.load(f)
    
    # Validate the mappings
    validate_feature_mappings(mappings)
    
    return mappings


def validate_feature_mappings(mappings: List[Dict]) -> bool:
    """Validate that feature mappings have the correct structure."""
    if not isinstance(mappings, list):
        raise ValueError("Feature mappings must be a list")
    
    if len(mappings) == 0:
        raise ValueError("Feature mappings cannot be empty")
    
    for i, mapping in enumerate(mappings):
        if not isinstance(mapping, dict):
            raise ValueError(f"Feature mapping {i} must be a dictionary")
        
        required_fields = ["feature_index", "feature_name", "data_type", "feature_group"]
        for field in required_fields:
            if field not in mapping:
                raise ValueError(f"Feature mapping {i} missing required field: {field}")
        
        if mapping["feature_index"] != i:
            raise ValueError(f"Feature mapping {i} has incorrect index: {mapping['feature_index']}")
    
    return True


def get_feature_group_for_index(index: int, mappings: List[Dict]) -> str:
    """
    Get the feature group name for a given feature index.
    
    Args:
        index: Feature index (0 to len(mappings)-1)
        mappings: Feature mappings list
        
    Returns:
        Feature group name
        
    Raises:
        ValueError: If index is out of range
    """
    if not 0 <= index < len(mappings):
        raise ValueError(f"Feature index must be 0-{len(mappings)-1}, got {index}")
    
    return mappings[index]['feature_group']


def get_feature_info(index: int, mappings: List[Dict]) -> Dict:
    """
    Get complete information for a specific feature index.
    
    Args:
        index: Feature index (0 to len(mappings)-1)
        mappings: Feature mappings list
        
    Returns:
        Feature information dictionary
    """
    if not 0 <= index < len(mappings):
        raise ValueError(f"Feature index must be 0-{len(mappings)-1}, got {index}")
    
    return mappings[index].copy()


def get_features_by_group(group_name: str, mappings: List[Dict]) -> List[Dict]:
    """
    Get all features belonging to a specific group.
    
    Args:
        group_name: Name of the feature group
        mappings: Feature mappings list
        
    Returns:
        List of feature mappings for the specified group
    """
    return [m for m in mappings if m['feature_group'] == group_name]


def get_features_by_type(data_type: str, mappings: List[Dict]) -> List[Dict]:
    """
    Get all features of a specific data type.
    
    Args:
        data_type: Data type to filter by
        mappings: Feature mappings list
        
    Returns:
        List of feature mappings with the specified data type
    """
    return [m for m in mappings if m['data_type'] == data_type]


def create_feature_mapping(feature_index: int, feature_name: str, 
                          original_value: Any, processed_value: float, 
                          context: str, data_type: str, feature_group: str) -> Dict:
    """
    Create a feature mapping entry (compatibility with legacy code).
    
    Args:
        feature_index: Feature index (0 to n-1)
        feature_name: Name of the feature
        original_value: Original value (unused in current implementation)
        processed_value: Processed value (unused in current implementation)
        context: Context information (unused in current implementation)
        data_type: Data type of the feature
        feature_group: Feature group name
        
    Returns:
        Feature mapping dictionary
    """
    return {
        'feature_index': feature_index,
        'feature_name': feature_name,
        'data_type': data_type,
        'feature_group': feature_group
    }


def print_feature_summary(mappings: List[Dict]) -> None:
    """
    Print a summary of all feature groups and their counts.
    
    Args:
        mappings: Feature mappings list
    """
    print("Feature Structure Summary:")
    print("=" * 50)
    
    group_counts = {}
    for mapping in mappings:
        group = mapping['feature_group']
        group_counts[group] = group_counts.get(group, 0) + 1
    
    for group, count in sorted(group_counts.items()):
        print(f"{group:20} : {count:3d} features")
    
    print(f"{'Total':20} : {len(mappings):3d} features")
    print("=" * 50)
